import{M as e,O as t,B as i,F as n,S as s,U as r,V as o,W as a,H as l,N as h,C as c,a as u,b as d,A as m,c as f,P as p,G as g,d as v,e as w,f as y,g as x,h as b,R as M,i as S,j as T,k as C,l as P,m as _,n as z,o as k,D as B,p as D}from"./three.DlEiv6SN.js";!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))t(e);new MutationObserver(e=>{for(const i of e)if("childList"===i.type)for(const e of i.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&t(e)}).observe(document,{childList:!0,subtree:!0})}function t(e){if(e.ep)return;e.ep=!0;const t=function(e){const t={};return e.integrity&&(t.integrity=e.integrity),e.referrerPolicy&&(t.referrerPolicy=e.referrerPolicy),"use-credentials"===e.crossOrigin?t.credentials="include":"anonymous"===e.crossOrigin?t.credentials="omit":t.credentials="same-origin",t}(e);fetch(e.href,t)}}();const F={name:"CopyShader",uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\n\t\t}"};class R{constructor(){this.isPass=!0,this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){}dispose(){}}const E=new t(-1,1,1,-1,0,1);const U=new class extends i{constructor(){super(),this.setAttribute("position",new n([-1,3,0,-1,-1,0,3,-1,0],3)),this.setAttribute("uv",new n([0,2,0,0,2,0],2))}};class A{constructor(t){this._mesh=new e(U,t)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,E)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}}class I extends R{constructor(e,t="tDiffuse"){super(),this.textureID=t,this.uniforms=null,this.material=null,e instanceof s?(this.uniforms=e.uniforms,this.material=e):e&&(this.uniforms=r.clone(e.uniforms),this.material=new s({name:void 0!==e.name?e.name:"unspecified",defines:Object.assign({},e.defines),uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader})),this._fsQuad=new A(this.material)}render(e,t,i){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=i.texture),this._fsQuad.material=this.material,this.renderToScreen?(e.setRenderTarget(null),this._fsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),this._fsQuad.render(e))}dispose(){this.material.dispose(),this._fsQuad.dispose()}}class L extends R{constructor(e,t){super(),this.scene=e,this.camera=t,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(e,t,i){const n=e.getContext(),s=e.state;let r,o;s.buffers.color.setMask(!1),s.buffers.depth.setMask(!1),s.buffers.color.setLocked(!0),s.buffers.depth.setLocked(!0),this.inverse?(r=0,o=1):(r=1,o=0),s.buffers.stencil.setTest(!0),s.buffers.stencil.setOp(n.REPLACE,n.REPLACE,n.REPLACE),s.buffers.stencil.setFunc(n.ALWAYS,r,4294967295),s.buffers.stencil.setClear(o),s.buffers.stencil.setLocked(!0),e.setRenderTarget(i),this.clear&&e.clear(),e.render(this.scene,this.camera),e.setRenderTarget(t),this.clear&&e.clear(),e.render(this.scene,this.camera),s.buffers.color.setLocked(!1),s.buffers.depth.setLocked(!1),s.buffers.color.setMask(!0),s.buffers.depth.setMask(!0),s.buffers.stencil.setLocked(!1),s.buffers.stencil.setFunc(n.EQUAL,1,4294967295),s.buffers.stencil.setOp(n.KEEP,n.KEEP,n.KEEP),s.buffers.stencil.setLocked(!0)}}class V extends R{constructor(){super(),this.needsSwap=!1}render(e){e.state.buffers.stencil.setLocked(!1),e.state.buffers.stencil.setTest(!1)}}class X{constructor(e,t){if(this.renderer=e,this._pixelRatio=e.getPixelRatio(),void 0===t){const i=e.getSize(new o);this._width=i.width,this._height=i.height,(t=new a(this._width*this._pixelRatio,this._height*this._pixelRatio,{type:l})).texture.name="EffectComposer.rt1"}else this._width=t.width,this._height=t.height;this.renderTarget1=t,this.renderTarget2=t.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],this.copyPass=new I(F),this.copyPass.material.blending=h,this.clock=new c}swapBuffers(){const e=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=e}addPass(e){this.passes.push(e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(e,t){this.passes.splice(t,0,e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(e){const t=this.passes.indexOf(e);-1!==t&&this.passes.splice(t,1)}isLastEnabledPass(e){for(let t=e+1;t<this.passes.length;t++)if(this.passes[t].enabled)return!1;return!0}render(e){void 0===e&&(e=this.clock.getDelta());const t=this.renderer.getRenderTarget();let i=!1;for(let n=0,s=this.passes.length;n<s;n++){const t=this.passes[n];if(!1!==t.enabled){if(t.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(n),t.render(this.renderer,this.writeBuffer,this.readBuffer,e,i),t.needsSwap){if(i){const t=this.renderer.getContext(),i=this.renderer.state.buffers.stencil;i.setFunc(t.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,e),i.setFunc(t.EQUAL,1,4294967295)}this.swapBuffers()}void 0!==L&&(t instanceof L?i=!0:t instanceof V&&(i=!1))}}this.renderer.setRenderTarget(t)}reset(e){if(void 0===e){const t=this.renderer.getSize(new o);this._pixelRatio=this.renderer.getPixelRatio(),this._width=t.width,this._height=t.height,(e=this.renderTarget1.clone()).setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=e,this.renderTarget2=e.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(e,t){this._width=e,this._height=t;const i=this._width*this._pixelRatio,n=this._height*this._pixelRatio;this.renderTarget1.setSize(i,n),this.renderTarget2.setSize(i,n);for(let s=0;s<this.passes.length;s++)this.passes[s].setSize(i,n)}setPixelRatio(e){this._pixelRatio=e,this.setSize(this._width,this._height)}dispose(){this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.copyPass.dispose()}}class Y extends R{constructor(e,t,i=null,n=null,s=null){super(),this.scene=e,this.camera=t,this.overrideMaterial=i,this.clearColor=n,this.clearAlpha=s,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new u}render(e,t,i){const n=e.autoClear;let s,r;e.autoClear=!1,null!==this.overrideMaterial&&(r=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),null!==this.clearColor&&(e.getClearColor(this._oldClearColor),e.setClearColor(this.clearColor,e.getClearAlpha())),null!==this.clearAlpha&&(s=e.getClearAlpha(),e.setClearAlpha(this.clearAlpha)),1==this.clearDepth&&e.clearDepth(),e.setRenderTarget(this.renderToScreen?null:i),!0===this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),e.render(this.scene,this.camera),null!==this.clearColor&&e.setClearColor(this._oldClearColor),null!==this.clearAlpha&&e.setClearAlpha(s),null!==this.overrideMaterial&&(this.scene.overrideMaterial=r),e.autoClear=n}}const W={uniforms:{tDiffuse:{value:null},luminosityThreshold:{value:1},smoothWidth:{value:1},defaultColor:{value:new u(0)},defaultOpacity:{value:0}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec3 defaultColor;\n\t\tuniform float defaultOpacity;\n\t\tuniform float luminosityThreshold;\n\t\tuniform float smoothWidth;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\tfloat v = luminance( texel.xyz );\n\n\t\t\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n\n\t\t\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n\n\t\t\tgl_FragColor = mix( outputColor, texel, alpha );\n\n\t\t}"};class O extends R{constructor(e,t=1,i,n){super(),this.strength=t,this.radius=i,this.threshold=n,this.resolution=void 0!==e?new o(e.x,e.y):new o(256,256),this.clearColor=new u(0,0,0),this.needsSwap=!1,this.renderTargetsHorizontal=[],this.renderTargetsVertical=[],this.nMips=5;let h=Math.round(this.resolution.x/2),c=Math.round(this.resolution.y/2);this.renderTargetBright=new a(h,c,{type:l}),this.renderTargetBright.texture.name="UnrealBloomPass.bright",this.renderTargetBright.texture.generateMipmaps=!1;for(let s=0;s<this.nMips;s++){const e=new a(h,c,{type:l});e.texture.name="UnrealBloomPass.h"+s,e.texture.generateMipmaps=!1,this.renderTargetsHorizontal.push(e);const t=new a(h,c,{type:l});t.texture.name="UnrealBloomPass.v"+s,t.texture.generateMipmaps=!1,this.renderTargetsVertical.push(t),h=Math.round(h/2),c=Math.round(c/2)}const p=W;this.highPassUniforms=r.clone(p.uniforms),this.highPassUniforms.luminosityThreshold.value=n,this.highPassUniforms.smoothWidth.value=.01,this.materialHighPassFilter=new s({uniforms:this.highPassUniforms,vertexShader:p.vertexShader,fragmentShader:p.fragmentShader}),this.separableBlurMaterials=[];const g=[3,5,7,9,11];h=Math.round(this.resolution.x/2),c=Math.round(this.resolution.y/2);for(let s=0;s<this.nMips;s++)this.separableBlurMaterials.push(this._getSeparableBlurMaterial(g[s])),this.separableBlurMaterials[s].uniforms.invSize.value=new o(1/h,1/c),h=Math.round(h/2),c=Math.round(c/2);this.compositeMaterial=this._getCompositeMaterial(this.nMips),this.compositeMaterial.uniforms.blurTexture1.value=this.renderTargetsVertical[0].texture,this.compositeMaterial.uniforms.blurTexture2.value=this.renderTargetsVertical[1].texture,this.compositeMaterial.uniforms.blurTexture3.value=this.renderTargetsVertical[2].texture,this.compositeMaterial.uniforms.blurTexture4.value=this.renderTargetsVertical[3].texture,this.compositeMaterial.uniforms.blurTexture5.value=this.renderTargetsVertical[4].texture,this.compositeMaterial.uniforms.bloomStrength.value=t,this.compositeMaterial.uniforms.bloomRadius.value=.1;this.compositeMaterial.uniforms.bloomFactors.value=[1,.8,.6,.4,.2],this.bloomTintColors=[new d(1,1,1),new d(1,1,1),new d(1,1,1),new d(1,1,1),new d(1,1,1)],this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,this.copyUniforms=r.clone(F.uniforms),this.blendMaterial=new s({uniforms:this.copyUniforms,vertexShader:F.vertexShader,fragmentShader:F.fragmentShader,blending:m,depthTest:!1,depthWrite:!1,transparent:!0}),this._oldClearColor=new u,this._oldClearAlpha=1,this._basic=new f,this._fsQuad=new A(null)}dispose(){for(let e=0;e<this.renderTargetsHorizontal.length;e++)this.renderTargetsHorizontal[e].dispose();for(let e=0;e<this.renderTargetsVertical.length;e++)this.renderTargetsVertical[e].dispose();this.renderTargetBright.dispose();for(let e=0;e<this.separableBlurMaterials.length;e++)this.separableBlurMaterials[e].dispose();this.compositeMaterial.dispose(),this.blendMaterial.dispose(),this._basic.dispose(),this._fsQuad.dispose()}setSize(e,t){let i=Math.round(e/2),n=Math.round(t/2);this.renderTargetBright.setSize(i,n);for(let s=0;s<this.nMips;s++)this.renderTargetsHorizontal[s].setSize(i,n),this.renderTargetsVertical[s].setSize(i,n),this.separableBlurMaterials[s].uniforms.invSize.value=new o(1/i,1/n),i=Math.round(i/2),n=Math.round(n/2)}render(e,t,i,n,s){e.getClearColor(this._oldClearColor),this._oldClearAlpha=e.getClearAlpha();const r=e.autoClear;e.autoClear=!1,e.setClearColor(this.clearColor,0),s&&e.state.buffers.stencil.setTest(!1),this.renderToScreen&&(this._fsQuad.material=this._basic,this._basic.map=i.texture,e.setRenderTarget(null),e.clear(),this._fsQuad.render(e)),this.highPassUniforms.tDiffuse.value=i.texture,this.highPassUniforms.luminosityThreshold.value=this.threshold,this._fsQuad.material=this.materialHighPassFilter,e.setRenderTarget(this.renderTargetBright),e.clear(),this._fsQuad.render(e);let o=this.renderTargetBright;for(let a=0;a<this.nMips;a++)this._fsQuad.material=this.separableBlurMaterials[a],this.separableBlurMaterials[a].uniforms.colorTexture.value=o.texture,this.separableBlurMaterials[a].uniforms.direction.value=O.BlurDirectionX,e.setRenderTarget(this.renderTargetsHorizontal[a]),e.clear(),this._fsQuad.render(e),this.separableBlurMaterials[a].uniforms.colorTexture.value=this.renderTargetsHorizontal[a].texture,this.separableBlurMaterials[a].uniforms.direction.value=O.BlurDirectionY,e.setRenderTarget(this.renderTargetsVertical[a]),e.clear(),this._fsQuad.render(e),o=this.renderTargetsVertical[a];this._fsQuad.material=this.compositeMaterial,this.compositeMaterial.uniforms.bloomStrength.value=this.strength,this.compositeMaterial.uniforms.bloomRadius.value=this.radius,this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,e.setRenderTarget(this.renderTargetsHorizontal[0]),e.clear(),this._fsQuad.render(e),this._fsQuad.material=this.blendMaterial,this.copyUniforms.tDiffuse.value=this.renderTargetsHorizontal[0].texture,s&&e.state.buffers.stencil.setTest(!0),this.renderToScreen?(e.setRenderTarget(null),this._fsQuad.render(e)):(e.setRenderTarget(i),this._fsQuad.render(e)),e.setClearColor(this._oldClearColor,this._oldClearAlpha),e.autoClear=r}_getSeparableBlurMaterial(e){const t=[];for(let i=0;i<e;i++)t.push(.39894*Math.exp(-.5*i*i/(e*e))/e);return new s({defines:{KERNEL_RADIUS:e},uniforms:{colorTexture:{value:null},invSize:{value:new o(.5,.5)},direction:{value:new o(.5,.5)},gaussianCoefficients:{value:t}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 invSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float gaussianCoefficients[KERNEL_RADIUS];\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tfloat weightSum = gaussianCoefficients[0];\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianCoefficients[i];\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}"})}_getCompositeMaterial(e){return new s({defines:{NUM_MIPS:e},uniforms:{blurTexture1:{value:null},blurTexture2:{value:null},blurTexture3:{value:null},blurTexture4:{value:null},blurTexture5:{value:null},bloomStrength:{value:1},bloomFactors:{value:null},bloomTintColors:{value:null},bloomRadius:{value:0}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}"})}}O.BlurDirectionX=new o(1,0),O.BlurDirectionY=new o(0,1);class H{constructor(t,i={}){this.options={index:0,position:new d(0,0,0),scale:1,blinkOffset:0,blinkSpeed:1,floatSpeed:.5,floatRadius:15,curiosity:.5,color:(new u).setHSL(.11+.05*Math.random(),.8,.5),...i},this.originalPosition=this.options.position.clone(),this.velocity=new d(30*(Math.random()-.5),30*(Math.random()-.5),30*(Math.random()-.5)),this.time=Math.random()*Math.PI*2,this.blinkIntensity=1,this.isBlinking=!0,this.targetIntensity=1,this.material=new s({uniforms:{time:{value:0},color:{value:this.options.color},intensity:{value:1},glowStrength:{value:3},coreSize:{value:.3}},vertexShader:"\n    varying vec2 vUv;\n    varying vec3 vNormal;\n    varying vec3 vPosition;\n    \n    void main() {\n        vUv = uv;\n        vNormal = normalize(normalMatrix * normal);\n        vPosition = position;\n        \n        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n        gl_Position = projectionMatrix * mvPosition;\n        \n        // Make point size responsive to distance\n        gl_PointSize = 10.0 * (300.0 / -mvPosition.z);\n    }\n",fragmentShader:"\n    uniform vec3 color;\n    uniform float intensity;\n    uniform float time;\n    uniform float glowStrength;\n    uniform float coreSize;\n    \n    varying vec2 vUv;\n    varying vec3 vNormal;\n    varying vec3 vPosition;\n    \n    void main() {\n        // Calculate distance from center for radial gradient\n        vec2 center = vec2(0.5, 0.5);\n        float dist = distance(vUv, center);\n        \n        // Create bright core with soft falloff\n        float coreGlow = 1.0 - smoothstep(0.0, coreSize, dist);\n        float outerGlow = 1.0 - smoothstep(coreSize, 1.0, dist);\n        \n        // Combine core and outer glow\n        float glow = coreGlow * 2.0 + outerGlow * glowStrength;\n        \n        // Add subtle pulsing\n        float pulse = sin(time * 3.0) * 0.1 + 0.9;\n        glow *= pulse;\n        \n        // Apply intensity and create HDR-ready color\n        vec3 glowColor = color * glow * intensity;\n        \n        // Add slight color variation based on intensity\n        if (intensity > 1.0) {\n            glowColor += vec3(0.2, 0.1, 0.0) * (intensity - 1.0);\n        }\n        \n        // Soft edge fade\n        float alpha = outerGlow * intensity;\n        \n        gl_FragColor = vec4(glowColor, alpha);\n    }\n",transparent:!0,blending:m,depthWrite:!1}),this.mesh=new e(t,this.material),this.mesh.position.copy(this.options.position),this.mesh.scale.setScalar(2*this.options.scale),this.mesh.rotation.set(Math.random()*Math.PI,Math.random()*Math.PI,Math.random()*Math.PI)}update(e,t,i,n){this.time+=e,this.material.uniforms.time.value=this.time,this.updateFloatingBehavior(e),this.updateBlinkingBehavior(e),this.updateMouseInteraction(t,i,n,e),this.mesh.position.add(this.velocity.clone().multiplyScalar(e)),this.wrapBoundaries(),this.material.uniforms.intensity.value=this.blinkIntensity}updateFloatingBehavior(e){const t=Math.sin(this.time*this.options.floatSpeed)*this.options.floatRadius,i=Math.sin(this.time*this.options.floatSpeed*1.3)*this.options.floatRadius*.7,n=Math.sin(this.time*this.options.floatSpeed*.7)*this.options.floatRadius*.5;this.velocity.x+=(t-this.velocity.x)*e*.1,this.velocity.y+=(i-this.velocity.y)*e*.1,this.velocity.z+=(n-this.velocity.z)*e*.1,Math.random()<.01&&this.velocity.add(new d(120*(Math.random()-.5),120*(Math.random()-.5),120*(Math.random()-.5))),this.velocity.multiplyScalar(.98)}updateBlinkingBehavior(e){const t=this.time*this.options.blinkSpeed+this.options.blinkOffset;if(this.isBlinking){const i=.5*Math.sin(t)+.5;Math.random()<.002?this.targetIntensity=1.5:Math.random()<.005?this.targetIntensity=.1:this.targetIntensity=i,this.blinkIntensity+=(this.targetIntensity-this.blinkIntensity)*e*5}this.blinkIntensity=Math.max(.1,Math.min(1.5,this.blinkIntensity))}updateMouseInteraction(e,t,i,n){if(!e||0===e.length())return;const s=this.mesh.position.distanceTo(e);if(s<t){const n=1-s/t,r=(new d).subVectors(this.mesh.position,e).normalize(),o=new d(-r.y,r.x,0).normalize(),a=n*i*this.options.curiosity,l=r.multiplyScalar(n*i*30),h=o.multiplyScalar(60*a);this.velocity.add(l),this.velocity.add(h),this.blinkIntensity=Math.min(this.blinkIntensity+.5*n,1.5)}}wrapBoundaries(){const e=500;this.mesh.position.x>e&&(this.mesh.position.x=-500),this.mesh.position.x<-500&&(this.mesh.position.x=e),this.mesh.position.y>e&&(this.mesh.position.y=-500),this.mesh.position.y<-500&&(this.mesh.position.y=e),this.mesh.position.z>250&&(this.mesh.position.z=-250),this.mesh.position.z<-250&&(this.mesh.position.z=250)}destroy(){this.material.dispose(),this.mesh.parent&&this.mesh.parent.remove(this.mesh)}}class N{constructor(){this.mesh=null,this.material=null,this.time=0,this.create()}create(){const t=new p(2,2);this.material=new s({uniforms:{time:{value:0},resolution:{value:new o(window.innerWidth,window.innerHeight)},intensity:{value:1}},vertexShader:"\n    varying vec2 vUv;\n    \n    void main() {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n",fragmentShader:"\n    uniform float time;\n    uniform vec2 resolution;\n    uniform float intensity;\n    \n    varying vec2 vUv;\n    \n    // Improved noise functions for organic patterns\n    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n    vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\n    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\n    float snoise(vec3 v) {\n        const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n        \n        vec3 i = floor(v + dot(v, C.yyy));\n        vec3 x0 = v - i + dot(i, C.xxx);\n        \n        vec3 g = step(x0.yzx, x0.xyz);\n        vec3 l = 1.0 - g;\n        vec3 i1 = min(g.xyz, l.zxy);\n        vec3 i2 = max(g.xyz, l.zxy);\n        \n        vec3 x1 = x0 - i1 + C.xxx;\n        vec3 x2 = x0 - i2 + C.yyy;\n        vec3 x3 = x0 - D.yyy;\n        \n        i = mod289(i);\n        vec4 p = permute(permute(permute(\n                 i.z + vec4(0.0, i1.z, i2.z, 1.0))\n               + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n               + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n               \n        float n_ = 0.142857142857;\n        vec3 ns = n_ * D.wyz - D.xzx;\n        \n        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n        \n        vec4 x_ = floor(j * ns.z);\n        vec4 y_ = floor(j - 7.0 * x_);\n        \n        vec4 x = x_ *ns.x + ns.yyyy;\n        vec4 y = y_ *ns.x + ns.yyyy;\n        vec4 h = 1.0 - abs(x) - abs(y);\n        \n        vec4 b0 = vec4(x.xy, y.xy);\n        vec4 b1 = vec4(x.zw, y.zw);\n        \n        vec4 s0 = floor(b0)*2.0 + 1.0;\n        vec4 s1 = floor(b1)*2.0 + 1.0;\n        vec4 sh = -step(h, vec4(0.0));\n        \n        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n        \n        vec3 p0 = vec3(a0.xy, h.x);\n        vec3 p1 = vec3(a0.zw, h.y);\n        vec3 p2 = vec3(a1.xy, h.z);\n        vec3 p3 = vec3(a1.zw, h.w);\n        \n        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n        p0 *= norm.x;\n        p1 *= norm.y;\n        p2 *= norm.z;\n        p3 *= norm.w;\n        \n        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n        m = m * m;\n        return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n    }\n    \n    // Create paint brush stroke texture\n    float brushStroke(vec2 uv, float angle, float width) {\n        vec2 rotated = vec2(\n            uv.x * cos(angle) - uv.y * sin(angle),\n            uv.x * sin(angle) + uv.y * cos(angle)\n        );\n        \n        // Irregular brush edges\n        float edge = snoise(vec3(rotated * 30.0, 0.0)) * 0.1;\n        float stroke = 1.0 - smoothstep(0.0, width + edge, abs(rotated.y));\n        \n        // Brush texture within stroke\n        float texture = snoise(vec3(rotated * 50.0, 1.0)) * 0.3 + 0.7;\n        \n        return stroke * texture;\n    }\n    \n    // Van Gogh style swirling vortex\n    vec2 vortex(vec2 uv, vec2 center, float strength, float time) {\n        vec2 offset = uv - center;\n        float dist = length(offset);\n        float angle = atan(offset.y, offset.x);\n        \n        // Spiral motion\n        angle += strength / (dist + 0.1) * sin(time * 0.5);\n        \n        // Distortion that varies with distance\n        float distortion = snoise(vec3(uv * 3.0, time * 0.1)) * 0.5;\n        angle += distortion * (1.0 - dist);\n        \n        return center + vec2(cos(angle), sin(angle)) * dist;\n    }\n    \n    // Multi-layered turbulence for depth\n    float layeredTurbulence(vec2 uv, float time, int layers) {\n        float value = 0.0;\n        float amplitude = 1.0;\n        vec2 shift = vec2(0.0);\n        \n        for(int i = 0; i < layers; i++) {\n            float layer = float(i);\n            vec2 coord = uv + shift;\n            \n            // Each layer has different flow direction\n            vec2 flow = vec2(\n                sin(time * (0.1 + layer * 0.05) + layer),\n                cos(time * (0.1 + layer * 0.03) + layer * 1.5)\n            ) * 0.1;\n            \n            coord += flow;\n            \n            // 3D noise for more organic feel\n            float noise = snoise(vec3(coord * (2.0 + layer), time * 0.05 + layer));\n            value += abs(noise) * amplitude;\n            \n            // Each layer shifts slightly\n            shift += vec2(noise) * 0.3;\n            amplitude *= 0.6;\n        }\n        \n        return value;\n    }\n    \n    // Paint-like color mixing\n    vec3 mixPaintColors(vec3 color1, vec3 color2, float factor, float texture) {\n        // Non-linear mixing for paint-like effect\n        float mixFactor = pow(factor, 1.5) * texture;\n        vec3 mixed = mix(color1, color2, mixFactor);\n        \n        // Add slight color variation\n        mixed += vec3(\n            snoise(vec3(mixed.xy * 10.0, 0.0)) * 0.05,\n            snoise(vec3(mixed.yz * 10.0, 1.0)) * 0.05,\n            snoise(vec3(mixed.zx * 10.0, 2.0)) * 0.05\n        );\n        \n        return mixed;\n    }\n    \n    void main() {\n        vec2 uv = vUv;\n        vec2 centeredUV = uv - 0.5;\n        float t = time * 0.3;\n        \n        // Create multiple vortex centers like in Starry Night\n        vec2 vortexUV = uv;\n        vortexUV = vortex(vortexUV, vec2(0.7, 0.6), 0.3, t);\n        vortexUV = vortex(vortexUV, vec2(0.3, 0.4), 0.25, t * 1.1);\n        vortexUV = vortex(vortexUV, vec2(0.5, 0.8), 0.2, t * 0.9);\n        vortexUV = vortex(vortexUV, vec2(0.2, 0.7), 0.15, t * 1.2);\n        \n        // Multi-layered turbulence\n        float turb1 = layeredTurbulence(vortexUV * 2.0, t, 5);\n        float turb2 = layeredTurbulence(vortexUV * 3.5 + vec2(10.0), t * 0.7, 4);\n        float turb3 = layeredTurbulence(vortexUV * 6.0 + vec2(20.0), t * 1.3, 3);\n        \n        // Create paint brush strokes\n        float brushPattern = 0.0;\n        for(int i = 0; i < 8; i++) {\n            float angle = float(i) * 0.785 + turb1 * 0.5; // 45 degree increments with variation\n            vec2 strokeUV = vortexUV * 10.0 + vec2(float(i) * 2.0);\n            brushPattern += brushStroke(strokeUV, angle, 0.1 + turb2 * 0.05) * 0.3;\n        }\n        \n        // Define Starry Night color palette\n        vec3 deepNightBlue = vec3(0.05, 0.08, 0.18);\n        vec3 prussianBlue = vec3(0.08, 0.12, 0.25);\n        vec3 midnightBlue = vec3(0.1, 0.15, 0.35);\n        vec3 royalBlue = vec3(0.15, 0.25, 0.55);\n        vec3 cobaltBlue = vec3(0.2, 0.35, 0.65);\n        vec3 darkPurple = vec3(0.15, 0.08, 0.25);\n        vec3 deepPurple = vec3(0.2, 0.1, 0.35);\n        vec3 moonYellow = vec3(0.9, 0.85, 0.5);\n        vec3 starWhite = vec3(0.95, 0.95, 0.9);\n        \n        // Base color with turbulence-based mixing\n        vec3 color = deepNightBlue;\n        \n        // Layer 1: Deep swirls\n        float swirl1 = smoothstep(0.2, 0.6, turb1);\n        color = mixPaintColors(color, prussianBlue, swirl1, brushPattern + 0.5);\n        \n        // Layer 2: Mid-tone blues\n        float swirl2 = smoothstep(0.3, 0.7, turb2);\n        color = mixPaintColors(color, midnightBlue, swirl2, 1.0 - brushPattern * 0.5);\n        \n        // Layer 3: Royal blue highlights\n        float swirl3 = smoothstep(0.4, 0.8, turb3);\n        color = mixPaintColors(color, royalBlue, swirl3 * 0.7, turb1);\n        \n        // Layer 4: Purple shadows\n        float purpleArea = snoise(vec3(vortexUV * 4.0, t * 0.1));\n        if(purpleArea < -0.2) {\n            color = mixPaintColors(color, darkPurple, -purpleArea, turb2);\n        }\n        \n        // Layer 5: Deep purple vortex cores\n        float vortexIntensity = 1.0 - length(vortexUV - vec2(0.7, 0.6)) * 3.0;\n        vortexIntensity = max(0.0, vortexIntensity);\n        color = mixPaintColors(color, deepPurple, vortexIntensity * 0.5, turb3);\n        \n        // Add cobalt blue swirls\n        float cobaltSwirl = sin(turb1 * 3.0 + turb2 * 2.0) * 0.5 + 0.5;\n        color = mixPaintColors(color, cobaltBlue, cobaltSwirl * 0.4, brushPattern);\n        \n        // Add impasto effect (thick paint texture)\n        float impasto = snoise(vec3(uv * 50.0, t * 0.05));\n        color *= 1.0 + impasto * 0.1;\n        \n        // Add stars and moon crescents\n        float stars = snoise(vec3(uv * 100.0, 5.0));\n        if(stars > 0.85) {\n            float starIntensity = (stars - 0.85) * 6.0;\n            color = mix(color, starWhite, starIntensity);\n        }\n        \n        // Add moon glow in specific areas\n        float moonDist = length(uv - vec2(0.8, 0.8));\n        if(moonDist < 0.15) {\n            float moonGlow = 1.0 - moonDist / 0.15;\n            moonGlow = pow(moonGlow, 2.0);\n            color = mix(color, moonYellow, moonGlow * 0.3);\n        }\n        \n        // Paint stroke direction highlights\n        float strokeHighlight = brushPattern * turb1;\n        color += vec3(0.05, 0.08, 0.15) * strokeHighlight;\n        \n        // Subtle color oscillation\n        color *= 0.95 + sin(t) * 0.05;\n        \n        // Vignette with paint texture\n        float vignette = 1.0 - length(centeredUV) * 0.7;\n        vignette = pow(vignette, 1.5);\n        color *= vignette;\n        \n        // Apply intensity\n        color *= intensity;\n        \n        // Final paint texture overlay\n        float finalTexture = snoise(vec3(uv * 80.0, 10.0)) * 0.05 + 0.95;\n        color *= finalTexture;\n        \n        gl_FragColor = vec4(color, 1.0);\n    }\n",depthWrite:!1,depthTest:!1}),this.mesh=new e(t,this.material),this.mesh.frustumCulled=!1,this.mesh.renderOrder=-1e3}update(e){this.time+=e,this.material.uniforms.time.value=this.time}setIntensity(e){this.material.uniforms.intensity.value=e}updateResolution(){this.material.uniforms.resolution.value.set(window.innerWidth,window.innerHeight)}dispose(){this.mesh.geometry&&this.mesh.geometry.dispose(),this.material&&this.material.dispose()}}class Q{constructor(){this.group=new g,this.branches=[],this.spawnPoints=[],this.time=0,this.swayAmount=.02,this.create()}create(){const t=200,i=Math.PI/5,n=new v(20,25,t,8),s=new w({color:7029795,emissive:4861722,emissiveIntensity:.3,shininess:15}),r=new e(n,s);r.position.y=100,this.group.add(r),this.generateBranches(new d(0,t,0),new d(0,1,0),20,100,3,.75,i),this.group.position.set(20,-180,-80)}generateBranches(t,i,n,s,r,o,a){if(r<=0||n<1)return;const l=new v(.6*n,n,s,6),h=new w({color:r>1?7029795:5913119,emissive:3810581,emissiveIntensity:.15}),c=new e(l,h),u=t.clone().add(i.clone().multiplyScalar(s)),m=t.clone().add(i.clone().multiplyScalar(s/2));c.position.copy(m),c.lookAt(u),c.rotateX(Math.PI/2),this.group.add(c),this.branches.push({mesh:c,depth:r,originalRotation:c.rotation.clone()});const f=Math.floor(3*Math.random())+1;for(let e=0;e<f;e++){const i=(e+1)/(f+1),n=t.clone().lerp(u,i);this.spawnPoints.push(n)}const p=r>1?Math.floor(3*Math.random())+2:Math.floor(4*Math.random())+3;for(let e=0;e<p;e++){const e=(Math.random()-.5)*a*2,t=(Math.random()-.5)*a*2,l=i.clone();l.applyAxisAngle(new d(1,0,0),e),l.applyAxisAngle(new d(0,0,1),t),l.normalize(),this.generateBranches(u,l,n*o,s*(.7+.3*Math.random()),r-1,o,1.2*a)}}update(e){this.time+=e,this.branches.forEach((e,t)=>{const{mesh:i,depth:n,originalRotation:s}=e,r=this.swayAmount*(4-n)*.3,o=Math.sin(.5*this.time+.1*t)*r,a=Math.cos(.7*this.time+.15*t)*r*.7;i.rotation.x=s.x+o,i.rotation.z=s.z+a}),this.group.rotation.z=.01*Math.sin(.3*this.time)}getSpawnPoints(){return this.spawnPoints.map(e=>{const t=e.clone();return this.group.localToWorld(t),t})}getBoundingBox(){const e=new y;return e.setFromObject(this.group),e}dispose(){this.branches.forEach(({mesh:e})=>{e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()})}}class j{constructor(e,t){this.scene=e,this.camera=t,this.particles=[],this.activeSwirls=new Map,this.clock=new c,this.config={particlesPerLetter:20,swirlRadius:100,swirlSpeed:2,swirlDuration:3,particleSize:3,fadeInTime:.3,fadeOutTime:.5,spiralTightness:.1,spiralExpansion:1.5,glowIntensity:2},this.materials=new Map,this.geometry=new i,this.setupGeometry()}setupGeometry(){const e=1e3,t=new Float32Array(3e3),i=new Float32Array(3e3),n=new Float32Array(e),r=new Float32Array(e),o=new Float32Array(e);this.geometry.setAttribute("position",new x(t,3)),this.geometry.setAttribute("color",new x(i,3)),this.geometry.setAttribute("size",new x(n,1)),this.geometry.setAttribute("alpha",new x(r,1)),this.geometry.setAttribute("time",new x(o,1)),this.material=new s({uniforms:{uTime:{value:0},uPixelRatio:{value:window.devicePixelRatio},uGlowIntensity:{value:this.config.glowIntensity}},vertexShader:"\n    attribute float size;\n    attribute float alpha;\n    attribute float time;\n    \n    varying vec3 vColor;\n    varying float vAlpha;\n    \n    uniform float uTime;\n    uniform float uPixelRatio;\n    \n    void main() {\n        vColor = color;\n        vAlpha = alpha;\n        \n        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n        \n        // Add some pulsing to the size based on time\n        float pulse = 1.0 + 0.2 * sin(time * 4.0 + uTime);\n        \n        gl_PointSize = size * pulse * uPixelRatio * (300.0 / -mvPosition.z);\n        gl_Position = projectionMatrix * mvPosition;\n    }\n",fragmentShader:"\n    varying vec3 vColor;\n    varying float vAlpha;\n    \n    uniform float uGlowIntensity;\n    \n    void main() {\n        // Create circular particle with glow\n        vec2 center = gl_PointCoord - vec2(0.5);\n        float dist = length(center);\n        \n        // Soft edge with glow\n        float alpha = 1.0 - smoothstep(0.0, 0.5, dist);\n        \n        // Add extra glow\n        float glow = exp(-dist * 3.0) * 0.5;\n        alpha += glow;\n        \n        // Apply color with glow intensity\n        vec3 finalColor = vColor * (1.0 + glow * uGlowIntensity);\n        \n        gl_FragColor = vec4(finalColor, alpha * vAlpha);\n        \n        // Discard fully transparent pixels\n        if (gl_FragColor.a < 0.01) discard;\n    }\n",transparent:!0,depthWrite:!1,blending:m}),this.points=new b(this.geometry,this.material),this.points.frustumCulled=!1,this.scene.add(this.points)}createSwirlFromElement(e,t={}){const i=`swirl_${Date.now()}_${Math.random()}`,n={...this.config,...t};e.textContent;const s=e.getBoundingClientRect(),r=s.left+s.width/2,o=s.top+s.height/2,a=this.screenToWorld(r,o),l=window.getComputedStyle(e),h=new u(l.color),c=e.querySelectorAll(".letter")||[e],m=[];return c.forEach((e,t)=>{const s=e.getBoundingClientRect(),r=s.left+s.width/2,o=s.top+s.height/2,a=this.screenToWorld(r,o);let l=h.clone();e.classList.contains("coral")?l=new u(16739179):e.classList.contains("yellow")&&(l=new u(16498468));for(let h=0;h<n.particlesPerLetter;h++){const e={id:`${i}_${t}_${h}`,originalPos:a.clone(),currentPos:a.clone(),velocity:new d,color:l,size:n.particleSize*(.5+.5*Math.random()),alpha:0,targetAlpha:1,phase:Math.random()*Math.PI*2,radius:n.swirlRadius*(.8+.4*Math.random()),speed:n.swirlSpeed*(.8+.4*Math.random()),spiralOffset:Math.random()*Math.PI*2,lifeTime:0,maxLifeTime:n.swirlDuration,letterIndex:t,totalLetters:c.length};m.push(e),this.particles.push(e)}}),this.activeSwirls.set(i,{particles:m,element:e,startTime:this.clock.getElapsedTime(),config:n,phase:"swirling",worldCenter:a}),e.style.opacity="0",e.style.transition=`opacity ${n.fadeInTime}s ease-out`,i}screenToWorld(e,t){const i=new d,n=window.innerWidth,s=window.innerHeight;i.x=e/n*2-1,i.y=-t/s*2+1,i.z=0,i.unproject(this.camera);const r=i.sub(this.camera.position).normalize(),o=-this.camera.position.z/r.z;return this.camera.position.clone().add(r.multiplyScalar(o))}updateSwirl(e,t){const i=this.activeSwirls.get(e);if(!i)return;const n=this.clock.getElapsedTime()-i.startTime,s=n/i.config.swirlDuration;i.particles.forEach((e,r)=>{if(e.lifeTime+=t,"swirling"===i.phase){const t=e.lifeTime*e.speed,n=e.radius*(1+i.config.spiralExpansion*s),r=e.spiralOffset+t,o=n*Math.cos(r)*s,a=n*Math.sin(r)*s,l=50*s*Math.sin(2*t);e.currentPos.x=i.worldCenter.x+o,e.currentPos.y=i.worldCenter.y+a,e.currentPos.z=i.worldCenter.z+l,e.alpha=s<.1?10*s:s>.8?5*(1-s):1,e.currentPos.x+=5*Math.sin(3*t+e.phase),e.currentPos.y+=5*Math.cos(2*t+e.phase)}else if("returning"===i.phase){const t=(n-i.config.swirlDuration)/i.config.fadeOutTime;if(t>=1)e.currentPos.copy(e.originalPos),e.alpha=0;else{const i=this.easeInOutCubic(t);e.currentPos.lerpVectors(e.currentPos,e.originalPos,.1*i),e.alpha=1-t}}}),"swirling"===i.phase&&s>=1?(i.phase="returning",i.startTime=this.clock.getElapsedTime()):"returning"===i.phase&&n>=i.config.fadeOutTime&&this.completeSwirl(e)}easeInOutCubic(e){return e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2}completeSwirl(e){const t=this.activeSwirls.get(e);t&&(t.element.style.opacity="1",t.particles.forEach(e=>{const t=this.particles.indexOf(e);t>-1&&this.particles.splice(t,1)}),this.activeSwirls.delete(e))}update(e){this.material.uniforms.uTime.value=this.clock.getElapsedTime(),this.activeSwirls.forEach((t,i)=>{this.updateSwirl(i,e)}),this.updateGeometry()}updateGeometry(){const e=this.geometry.attributes.position.array,t=this.geometry.attributes.color.array,i=this.geometry.attributes.size.array,n=this.geometry.attributes.alpha.array,s=this.geometry.attributes.time.array;this.particles.forEach((r,o)=>{const a=3*o;e[a]=r.currentPos.x,e[a+1]=r.currentPos.y,e[a+2]=r.currentPos.z,t[a]=r.color.r,t[a+1]=r.color.g,t[a+2]=r.color.b,i[o]=r.size,n[o]=r.alpha,s[o]=r.lifeTime});for(let r=this.particles.length;r<e.length/3;r++)n[r]=0;this.geometry.attributes.position.needsUpdate=!0,this.geometry.attributes.color.needsUpdate=!0,this.geometry.attributes.size.needsUpdate=!0,this.geometry.attributes.alpha.needsUpdate=!0,this.geometry.attributes.time.needsUpdate=!0,this.geometry.setDrawRange(0,this.particles.length)}triggerRandomSwirl(){const e=[...document.querySelectorAll(".band-name"),document.querySelector(".venue-name"),document.querySelector(".date-display")].filter(e=>e&&!this.isElementSwirling(e));if(e.length>0){const t=e[Math.floor(Math.random()*e.length)];this.createSwirlFromElement(t)}}isElementSwirling(e){for(const[t,i]of this.activeSwirls)if(i.element===e)return!0;return!1}destroy(){this.geometry.dispose(),this.material.dispose(),this.scene.remove(this.points),this.activeSwirls.forEach((e,t)=>{e.element.style.opacity="1"}),this.activeSwirls.clear(),this.particles=[]}}class G{constructor(e,t){this.scene=e,this.camera=t,this.elements=new Map,this.mouse=new o,this.mouseWorld=new d,this.raycaster=new M,this.config={influenceRadius:250,springStiffness:.12,damping:.92,maxDisplacement:150,returnForce:.08,zDepth:.8,rotationEffect:.0015,minDistance:30,stickiness:.25},this.setupEventListeners()}addElement(e,t={}){const i=`follow_${Date.now()}_${Math.random()}`,n=e.getBoundingClientRect(),s={element:e,originalX:n.left+n.width/2,originalY:n.top+n.height/2,currentX:n.left+n.width/2,currentY:n.top+n.height/2,velocityX:0,velocityY:0,rotation:0,scale:1,config:{...this.config,...t}};e.style.position="relative",e.style.transition="none",e.style.willChange="transform",e.style.transformOrigin="center center",e.style.transform="translateZ(0)";const r=e.querySelectorAll(".letter");return r.length>0&&(s.letters=[],r.forEach((e,t)=>{const i=e.getBoundingClientRect();e.style.position="relative",e.style.display="inline-block",e.style.transition="none",e.style.willChange="transform",s.letters.push({element:e,originalX:i.left+i.width/2,originalY:i.top+i.height/2,currentX:i.left+i.width/2,currentY:i.top+i.height/2,velocityX:0,velocityY:0,rotation:0,delay:.02*t,amplitude:1+t%3*.2})})),this.elements.set(i,s),i}removeElement(e){const t=this.elements.get(e);t&&(t.element.style.transform="",t.element.style.position="",t.element.style.transition="",t.element.style.willChange="",t.letters&&t.letters.forEach(e=>{e.element.style.transform="",e.element.style.position="",e.element.style.transition="",e.element.style.willChange=""}),this.elements.delete(e))}setupEventListeners(){window.addEventListener("mousemove",e=>{this.mouse.x=e.clientX,this.mouse.y=e.clientY;const t=e.clientX/window.innerWidth*2-1,i=-e.clientY/window.innerHeight*2+1;this.raycaster.setFromCamera({x:t,y:i},this.camera);const n=new S(new d(0,0,1),0);this.raycaster.ray.intersectPlane(n,this.mouseWorld)}),window.addEventListener("touchmove",e=>{if(e.touches.length>0){const t=e.touches[0];this.mouse.x=t.clientX,this.mouse.y=t.clientY}})}update(e){this.elements.forEach(t=>{this.updateElement(t,e),t.letters&&t.letters.forEach(i=>{this.updateLetter(i,t.config,e)})})}updateElement(e,t){const i=e.config,n=this.parseTransform(e.element),s=e.element.getBoundingClientRect(),r=s.left+s.width/2-n.x,o=s.top+s.height/2-n.y;e.initialized||(e.originalX=r,e.originalY=o,e.currentX=r,e.currentY=o,e.initialized=!0);const a=this.mouse.x-e.currentX,l=this.mouse.y-e.currentY,h=Math.sqrt(a*a+l*l),c=Math.max(0,1-h/i.influenceRadius);if(c>0){let t=i.springStiffness;h<i.minDistance&&(t+=i.stickiness*(1-h/i.minDistance));const n=a*c*t,s=l*c*t;e.velocityX+=n,e.velocityY+=s}const u=e.originalX-e.currentX,d=e.originalY-e.currentY,m=Math.sqrt(u*u+d*d),f=i.returnForce*(1+m/i.maxDisplacement);e.velocityX+=u*f,e.velocityY+=d*f,e.velocityX*=i.damping,e.velocityY*=i.damping,e.currentX+=e.velocityX,e.currentY+=e.velocityY;const p=e.currentX-e.originalX,g=e.currentY-e.originalY,v=Math.sqrt(p*p+g*g);if(v>i.maxDisplacement){const t=i.maxDisplacement/v;e.currentX=e.originalX+p*t,e.currentY=e.originalY+g*t}e.rotation=e.velocityX*i.rotationEffect;const w=e.currentX-e.originalX,y=e.currentY-e.originalY,x=20*c*i.zDepth;e.element.style.transform=`translate3d(${w}px, ${y}px, ${x}px) rotate(${e.rotation}rad) scale(${1+.08*c})`}updateLetter(e,t,i){const n=this.mouse.x-e.currentX,s=this.mouse.y-e.currentY,r=Math.sqrt(n*n+s*s),o=Math.max(0,1-r/t.influenceRadius)*e.amplitude;if(o>0){const i=n*o*t.springStiffness*1.2,r=s*o*t.springStiffness*1.2;e.velocityX+=i,e.velocityY+=r}const a=e.originalX-e.currentX,l=e.originalY-e.currentY;e.velocityX+=a*t.returnForce*(1+e.delay),e.velocityY+=l*t.returnForce*(1+e.delay),e.velocityX*=t.damping,e.velocityY*=t.damping,e.currentX+=e.velocityX,e.currentY+=e.velocityY;const h=e.currentX-e.originalX,c=e.currentY-e.originalY,u=e.velocityX*t.rotationEffect*2,d=1+.1*o*Math.sin(.001*Date.now()+10*e.delay);e.element.style.transform=`translate3d(${h}px, ${c}px, 0px) rotate(${u}rad) scale(${d})`}parseTransform(e){const t=window.getComputedStyle(e).transform;if("none"===t)return{x:0,y:0};const i=t.match(/matrix.*\((.+)\)/);if(i){const e=i[1].split(", ");return{x:parseFloat(e[4])||0,y:parseFloat(e[5])||0}}return{x:0,y:0}}setConfig(e){Object.assign(this.config,e),this.elements.forEach(e=>{e.config={...this.config,...e.config}})}destroy(){this.elements.forEach((e,t)=>{this.removeElement(t)}),this.elements.clear()}}class ${constructor(e=document.body){this.container=e,this.fireflies=[],this.firefliesForeground=[],this.firefliesBackground=[],this.mouse=new o,this.mouseWorld=new d,this.raycaster=new M,this.background=null,this.tree=null,this.backgroundScene=null,this.backgroundCamera=null,this.textSwirl=null,this.mouseFollowText=null,this.config={fireflyCount:250,fireflyScale:1,mouseRadius:200,mouseForce:.5,environmentColor:new u(657966),fogColor:new u(657966),fogNear:1,fogFar:1e3,bloomStrength:4,bloomRadius:1.2,bloomThreshold:.05},this.init(),this.createBackground(),this.createTree(),this.createFireflies(),this.createMouseFollowText(),this.setupEventListeners(),this.animate()}init(){this.scene=new T,this.scene.fog=new C(this.config.fogColor,this.config.fogNear,this.config.fogFar),this.backgroundScene=new T,this.backgroundCamera=new t(-1,1,1,-1,0,1),this.camera=new P(75,window.innerWidth/window.innerHeight,.1,1e3),this.camera.position.set(-50,50,350),this.camera.lookAt(0,0,0),this.renderer=new _({antialias:!0,alpha:!1}),this.renderer.setSize(window.innerWidth,window.innerHeight),this.renderer.setPixelRatio(Math.min(window.devicePixelRatio,2)),this.renderer.toneMapping=z,this.renderer.toneMappingExposure=1.8,this.renderer.autoClear=!1;const e=document.getElementById("particles");e?(e.replaceWith(this.renderer.domElement),this.renderer.domElement.id="particles"):this.container.appendChild(this.renderer.domElement),this.composer=new X(this.renderer);const i=new Y(this.scene,this.camera);this.composer.addPass(i);const n=new O(new o(window.innerWidth,window.innerHeight),this.config.bloomStrength,this.config.bloomRadius,this.config.bloomThreshold);this.composer.addPass(n);const s=new k(1710654,.15);this.scene.add(s);const r=new B(5930933,.4);r.position.set(50,100,50),this.scene.add(r);const a=new B(8425632,.2);a.position.set(-100,50,-50),this.scene.add(a)}createBackground(){this.background=new N,this.backgroundScene.add(this.background.mesh)}createTree(){this.tree=new Q,this.scene.add(this.tree.group)}createFireflies(){const e=new D(1,16,16),t=this.tree.getSpawnPoints(),i=this.tree.getBoundingBox();for(let n=0;n<this.config.fireflyCount;n++){let s;if(n<.3*this.config.fireflyCount&&t.length>0){s=t[Math.floor(Math.random()*t.length)].clone(),s.add(new d(80*(Math.random()-.5),80*(Math.random()-.5),60*(Math.random()-.5)))}else if(n<.7*this.config.fireflyCount){const e=Math.random()<.5?-1:1,t=350+100*Math.random();s=new d(e*t,600*(Math.random()-.5),400*(Math.random()-.5))}else s=new d(900*(Math.random()-.5),700*(Math.random()-.5),500*(Math.random()-.5));const r=new H(e,{index:n,position:s,scale:.5*Math.random()+.5,blinkOffset:Math.random()*Math.PI*2,blinkSpeed:.5*Math.random()+.5,floatSpeed:.3*Math.random()+.2,floatRadius:20*Math.random()+10,curiosity:.7*Math.random()+.3});this.fireflies.push(r),s.z>i.min.z?(this.firefliesForeground.push(r),r.mesh.renderOrder=1):(this.firefliesBackground.push(r),r.mesh.renderOrder=-1),this.scene.add(r.mesh)}}createTextSwirl(){this.textSwirl=new j(this.scene,this.camera),this.textSwirl.config={...this.textSwirl.config,particlesPerLetter:15,swirlRadius:80,swirlSpeed:1.5,swirlDuration:2.5,particleSize:2.5,glowIntensity:2.5}}createMouseFollowText(){this.mouseFollowText=new G(this.scene,this.camera),this.mouseFollowText.config={...this.mouseFollowText.config,influenceRadius:100,springStiffness:.08,damping:.85,maxDisplacement:50,returnForce:.06,zDepth:.5,rotationEffect:5e-4,minDistance:20,stickiness:.3}}updateFireflies(e){this.fireflies.forEach(t=>{t.update(e,this.mouseWorld,this.config.mouseRadius,this.config.mouseForce)})}updateBackground(e){this.background&&this.background.update(e)}updateTree(e){this.tree&&this.tree.update(e)}animate(){requestAnimationFrame(()=>this.animate());const e=this.clock?this.clock.getDelta():0;this.clock||(this.clock=new c),this.updateBackground(e),this.updateTree(e),this.updateFireflies(e),this.mouseFollowText&&this.mouseFollowText.update(e),this.renderer.clear(),this.renderer.render(this.backgroundScene,this.backgroundCamera),this.composer.render()}setupEventListeners(){window.addEventListener("mousemove",e=>{this.mouse.x=e.clientX/window.innerWidth*2-1,this.mouse.y=-e.clientY/window.innerHeight*2+1,this.raycaster.setFromCamera(this.mouse,this.camera);const t=new S(new d(0,0,1),0);this.raycaster.ray.intersectPlane(t,this.mouseWorld)}),window.addEventListener("resize",()=>{this.camera.aspect=window.innerWidth/window.innerHeight,this.camera.updateProjectionMatrix(),this.renderer.setSize(window.innerWidth,window.innerHeight),this.composer.setSize(window.innerWidth,window.innerHeight),this.background&&this.background.updateResolution()}),window.addEventListener("touchmove",e=>{if(e.touches.length>0){const t=e.touches[0];this.mouse.x=t.clientX/window.innerWidth*2-1,this.mouse.y=-t.clientY/window.innerHeight*2+1,this.raycaster.setFromCamera(this.mouse,this.camera);const i=new S(new d(0,0,1),0);this.raycaster.ray.intersectPlane(i,this.mouseWorld)}})}setConfig(e){Object.assign(this.config,e),e.environmentColor&&(this.scene.background=new u(e.environmentColor)),(e.fogColor||e.fogNear||e.fogFar)&&(this.scene.fog=new C(this.config.fogColor,this.config.fogNear,this.config.fogFar))}destroy(){this.fireflies.forEach(e=>e.destroy()),this.background&&this.background.dispose(),this.tree&&this.tree.dispose(),this.textSwirl&&this.textSwirl.destroy(),this.mouseFollowText&&this.mouseFollowText.destroy(),this.renderer.dispose(),this.composer.dispose()}}document.addEventListener("DOMContentLoaded",()=>{const e=new $(document.body);window.fireflySystem=e,e.setConfig({fireflyCount:180,fogColor:657966,fogNear:50,fogFar:600,bloomStrength:3.5,bloomRadius:1.2,bloomThreshold:0,mouseRadius:200,mouseForce:.5}),window.addEventListener("beforeunload",()=>{e.destroy()}),document.querySelectorAll(".band-name[data-url]").forEach(e=>{"#"!==e.dataset.url&&(e.style.cursor="pointer",e.addEventListener("click",t=>{t.preventDefault(),window.open(e.dataset.url,"_blank")}))});setTimeout(()=>{if(!e.mouseFollowText)return;const t=document.querySelector(".date-display");t&&e.mouseFollowText.addElement(t,{influenceRadius:120,springStiffness:.15,maxDisplacement:60,returnForce:.12,stickiness:.35,damping:.85,minDistance:20});const i=document.querySelector(".tagline");i&&e.mouseFollowText.addElement(i,{influenceRadius:100,springStiffness:.12,maxDisplacement:50,damping:.88,stickiness:.25,returnForce:.1,minDistance:15})},600)});
